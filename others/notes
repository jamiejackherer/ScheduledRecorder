da fare:
- cercare info su dove mettere il codice di gestione fragment nel modello mvvm
- cercare info su testing del viewmodel
- testare il viewmodel
- funzione cancellazione scheduled recordings superate nel database


OBJ: LISTENER PER AZIONI UTENTE

Per le interazioni dell’utente (es. click) si utilizza una classe listener come variable.
Per questa classe definisco un’interfaccia: ovviamente i metodi dell’interfaccia devono
essere coerenti con i metodi interessati della UI – es. se ho un metodo onClick di tipo void
dovrà essere di tipo void anche nell’interfaccia, ecc.).

I listener li posso implementare nel Fragment/Activity, impostare sul view model lì, e nei listener
eseguire le operazioni volute, anche richiamando metodi del viewmodel se necessario.

Alcuni metodi però li si può far gestire direttamente dal viewmodel senza interessare il layout:
es. voce di menu che mi cancella il task (nel mio caso esempio per salvare il recording).

Salvo il recording: la mia Activity deve chiudersi e devo rimostrare la lista aggiornata.
Introdurre classe SingleLiveEvent.
Nel view model inserire e creare variabile di tale tipo con metodo getter. E quando si salva il
recording chiamare call su di essa.
Nella mia Activity registrarsi su tale variabile come observer e creare un metodo dove si chiude
l’Activity con risultato ok.











OBJ: VISUALIZZARE I DATI

Passo l'id e scarico i dati del task dal database col view model.

LAYOUT CON DATA BINDING (TASKDETAIL_FRAG.XML)

Uso come variable il ViewModel (per i dati).
Per impostare la visibility delle View sfrutto un campo interno al ViewModel che dice se i dati sono
in caricamento o no (View è un import):
android:visibility="@{viewmodel.dataAvailable ? View.VISIBLE : View.GONE}"

I dati da visualizzare li prende dal ViewModel:
android:text="@{viewmodel.task.title}"
android:text="@{viewmodel.task.description}"

VIEWMODEL (TASKDETAILVIEWMODEL.JAVA)
Usa la repository per recuperare il task. Per questo implementa l’interfaccia della repository per
ricevere il task o il metodo d’errore.
Tiene il task al suo interno come ObservableField. Basta che abbia il getter per il task e il
layout lo può utilizzare. Per accedere ai campi del task basta che ci siano i getter nel task, non
occorre metterli anche nel view model.

Usa una variabile boolean per indicare che i dati sono in caricamento/caricati (se il mio metodo
è isDataLoading nel layout lo referenzio come dataLoading, come accade col get).